## 인덱스 
화일의 레코드들에 효율적으로 접근하기 위해서 
키, 주소

- 기본, 보조 
- 집중, 비집중
- 밀집, 희소


## 트리
- 차수
- 높이

## 이진트리


## 이진 탐색트리 

1. 검색
2. 삽입
3. 삭제
	1. 단말 노드인 경우
	2. 자식이 하나인 경우
	3. 자식이 두개인 경우

성능 
1. 가장 자주 접근하는 노드 -> 루트에 가장 가깝게
2. 이진탐색트리를 균형트리로 유지

하면 성능이 좋아진다.

단점
- 삽입, 삭제 후 균형유지 부담이 크다. 
- 분기율이 작아(2) 탐색 경로가 길고 검색 시간이 길다 -> 분기가 5개라면? 검색시 더 효과적?
- n개의 노드를 갖는 트리의 최소 높이: [log N] +1


## 편향 이진 탐색 트리 
최악 n개 노드일때, n번 탐색

## AVL트리 = 높이 균형 이진트리 
- 삽입 삭제 검색 시간 O(logN)
- 각 노드의 왼쪽 서브트리의 높이)와 오른쪽 서브트리의 높이 차이가 1이하인 이진탐색 트리
- BF = 균형인수  = h( LEFT(T)) - h(RIGHT(T))
- 균형인수가 +-1이하이다.
- 공백트리의 높이는 -1로 계산 

- 검색 - 일반 이진탐색트리랑 같음 log N
- 삽입 - 불균형이 되었을시 조정해야함 

1. 양수일때 왼쪽 서브트리에 문제
2. 음수일때 오른쪽 서브트리에 문제

- 회전
		1. LL: x의 왼쪽 자식의 왼쪽 서브트리에 삽입 -> LL 회전: 문제 구간 중 상위 구간을 오른쪽으로 회전
		2. RR: x의 오른쪽 자식의 오른쪽 서브트리에 삽입 -> RR 회전 : 문제 구간 중 상위 구간을 왼쪽으로 회전
		3. LR: x의 왼쪽 자식의 오른쪽 서브트리에 삽입 -> LR 회전: 문제 구간 중 하위 구간을 왼쪽으로 1차 회전시켜 LL 유형으로 변환한다음. LL회전을 적용함
		4. RL: x의 오른쪽 자식의 왼쪽 서브트리에 삽입 -> RL 회전: 문제 구간 중 하위구간을 오른쪽으로 1차 회전시켜 RR 유형으로 변환한다음. RR 회전을 적용함.
	

삽입으로 인해 영향을 받는건 **새로운 노드~루트** 뿐임

AVL트리 vs 완전 균형 이진 트리
- AVL 트리의 탐색 시간이 더 길지만, 완전균형이진트리는 트리 전체 재균형을 수행해야한다.

AVL트리는 메인 메모리에 거주하는 내부 구조로서, 트리 크기가 너무 커서 메인 메모리에 구축 할 수 없을 경우에 쓴다. ex ) 균형 m-원 탐색 트리 (b트리)

