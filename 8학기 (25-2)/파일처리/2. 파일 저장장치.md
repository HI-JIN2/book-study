# 저장장치
- 저장장치 = 저장매체 + 매체에 데이터를 저장하고 검색하기 위한 장치
- 저장매체: 소멸성 vs 비소멸성
- 접근장치: 데이터를 판독하거나 기록하는 장치

1. 1차 저장장치
	1. ==메인 메모리==
	2. ==캐시 메모리==
2. 2차 저장장치
	1. 자기디스크 : 데이터 접근이 느리다. 하지만 싸서 화일 저장에 쓰인다.
		1. ==하드디스크==
		2. 유연한 디스크
	2. 플로피 디스크
	3. 광 디스크
	4. 자기 테이프

  


| 고가  <br> | 캐시 메모리  | 빠름  |
| -------- | ------- | --- |
|          | 메인 메모리  |     |
|          | 플래시 메모리 |     |
| **비용**   | 자기 디스크  | 속도  |
|          | 광 디스크   |     |
| 저가       | 자기 테이프  | 느림  |
# 저장장치의 유형

## 1. 캐시메모리
- 가장 빠르고 가장 비쌈
- SRAM(static random access memeory)
- 데이터를 유지하기 위해 자주 재생할 필요가 없음
- 메인메모리 성능향상 목적

## 2. 메인 메모리
- 프로그램 실행과 이에 필요한 데이터 유지 공간
- DRAM (dynamic random access memory)
- 용량이 적고 소멸성(데이터 저장에는 부적합)
- 내용 접근 시간은 일정하고 빠름
- 프로그램/데이터를 처리하기 위한 작업공간

## 3 .플래시 메모리
- 고밀도 고성능 메모리로서 비소멸성
- 메인 메모리와 비슷한 접근 속도
- 재기록 시 한 블록 전체를 동시에 지우고 기록해야함

## 4. 자기 디스크
- 데이터 저장 장치의 주 매체
- 데이터 처리와 기록은 메인 메모리를 거쳐야함
- 대용량이고 비소멸성

- 직접 접근 저장 장치 중 가장 많이 쓰임
- 종류
	1) 하드디스크
	2) 유연한 디스크 : 플로피 디스크 등
- 분류 기준
	- 기록 표면수
	- 데이터 전송률
	- 기록/판독 헤드 이동시간
	- 접근 방법
	- 회전 지연
	- 밀도
### 4-1. 자기 디스크의 물리적 특성
1. 디스크 팩
	1. 디스크 원반의 모음
	2. 양면 사용(맨위, 맨아래는 제외. 11개 디스크는 20면)
2. 디스크 구동기
	1. 제어기, 접근 암, 판독기록 헤드, 팩 회전 장치
	2. 고정식, 탈착식
3. 디스크 제어기
	1. 원하는 데이터가 어느 구동기, 어느 면, 어느 주소에 있는지 판독
	2. 버퍼 관리
	3. 오류 발견,수정
	4. 판독 기록 관리
	
### 4-2. 데이터 저장
- 트랙: 갭으로 분리된 섹터들로 구성
- 섹터: 기록과 판독 작업의 최소 단위 
- 실린더: 지름이 같은 모든 트랙(헤드가 읽을때 실린더를 한번에 읽음)

- 블록: 디스크와 메인 메모리 사이에 전송되는 데이터의 논리적 다누이
- 블록은 하나 이상의 섹터로 구성

### 4-3. 유동 헤드 디스크와 고정 헤드 디스크
1. 유동 헤드 디스크 
	1. 각 기록 면마다 판독 기록 헤드가 있음
	2. 판독 기록시 헤드가 원하는 트랙에 위치하도록 엑세스암을 이동
	3. ==전송 시간 = 데이터를 동일면 보다 동일 실린더에 저장하는 것이 효율적==
2. 고정 헤드 디스크
	1. 기록면의 각 트랙마다 하나의 판독기록 헤드가 있음
	2. 판독기록을 위해 헤드를 이동시킬 필요가 없음

### 4-4. 윈체스터 디스크
- 보편적인 하드디스크가 윈체스터 디스크임
- 기록면, 접근 장치, 판독 기록 헤드가 함께 밀봉
- 기록 밀도가 높음 -헤드가 디스크에 근접
- 회전속도 5400~10000rpm
- 단일 최대용량은 30TB (4년뒤 두배 예상)
## 5. 플로피 디스크
- 이젠 안씀
- 유연한 디스크
- 회전속도 360rpm
- 수직축 기록: 저장용량을 늘리기 위한 신기술(표면과 수직방향으로 자화시켜 각 자화점의 표면 폭을 축소시킴. 밀도 50배 이상 향상)


## 디스크 저장장치의 특성
1. 디스크 특성요소
	1. 회전 속도
	2. 디스크 드라이브의 원반수(원반수에 2곱하면 기록면 개수)
	3. 기록 면당 트랙수
	4. 트랙당 섹터수
	5. 섹터당 바이트 수
	 =>다 곱하면 용량이 나온다

2. ==데이터 접근 시간==
	1. 탐구시간 s
	2. 회전 지연시간 r = 1/2 * 1회전시간
		* 회전 속도가 3,600rpm인 디스크에서 r은 몇 ms?  60sec : 3600 = x : 1  , x=8.33ms
	3. 전송시간 t
3. ==블로킹==
	1. 블로킹 : 디스크와 메인메모리 사이의 데이터 전송 단위: 물리적레코드
	2. 트랙의 길이 = b * B
	3. 블록의 길이 < = 트랙의 길이
	4. 블록의 크기
		1. 보통 512byte, 1kb, 4km
		2. 너무 크면 불필요한 데이터 전송을야기
		3. 과다한 버퍼할당으로 메모리 효율성을 저하
	5. ==블로킹 인수 BF = 한 블록에 포함시킬 수 있는 논리적 레코드 수==
		- 메인 메모리와 입출력 효율을 위해 몇개의 논리적 레코드를 하나의 물리적 레코드에 저장시키는 것
		- 논리적 레코드 = 사용자가 데이터를 저장하기 위한 논리적 단위
	6. 블로킹 방법
		![[Pasted image 20250428213925.png]]
		1. 고정길이 블로킹
			1. 레코드의 길이를 기록하지 않아도됨
		2. 신장된 가변길이 블로킹
			1. 신장 = 한 레코드가 인접한 몇개의 블록에 걸쳐 저장
			2. 효율적으로 저장되긴함 (낭비 x) 
			3. 레코드의 길이 정보도 기록 해야함(R4가 쪼개져 있다는 정보를 저장해야함)
		3. 비신장된 가변길이 블로킹
			1. 하나의 레코드를 쪼개진 않음
			2. 그냥 가변길이이기만 함
	7. 레코드와 블록
		1. 블록헤더= 블록내의 레코드 수, 블록 아이디, 블록 수정 날짜,....... 부가적인 정보를 저장
		2. 고정길이 블로킹일때는 레코드의 길이만 알면 레코드를 구분할 수 있다.
		3. ==가변길이 블로킹일때는 레코드의 길이가 다 다르기 때문에 길이를 적어줘야함==
			1. 레코드 끝 마크 = 레코드 사이에 분리 표시
			2. 각 레코드 앞에 길이 지시자
			3. 블록 헤더위에 위치 테이블
			4. 하지만 블록헤더에 저장을 너무 많이해서 블록 안에 있는 레코드가 작아지는 것을 조심해야함
		4. 레코드 설계시 고려사항
			1. 메인 메모리 바이트 주소(4의 배수) 특성
			2. 레코드 헤더
			3. 각 필드는 레코드의 오프셋으로 표현 가능
	8. ==블로킹의 고려사항==
		1. ==적재 밀도==
			1. 갱신(삽입)을 위한 블록 내의 자유공간의 할당
			2. ==실제 데이터가 저장된 공간과 자유공간을 포함한 총 공간과의 비율==
		2. ==균형 밀도==
			1. 레코드 자체의 확장과 축소
			2. 상당히 긴 시간 동안 시스템을 운용하고 안정시킨 뒤에 예상되는 저장 밀도
		3. ==집약성==
			1. 상호 연관이 있는 레코드들의 물리적 접근성
			2. 같은 블록, 트랙, 실린더

# RAID
1. 디스크 신뢰성
2. 디스크 병렬성
	1. 데이터 스트라이핑을 통해서 전송률을 개선

## RAID 0
## RAID 1

## RAID 2

## RAID 5

## RAID 6