
# 정렬
## 내부 정렬
- 전체 데이터를 메인메모리에 올릴 수 있을 때
- 레코드 판독, 기록에 걸리는 시간이 문제가 되지 않음
- 종류 
	1. 버블 
	2. 삽입
	3. 선택
	4. 퀵
	5. 힙
	6. 병합

## 외부 정렬
- 데이터가 너무 커서 메인 메모리에 한 번에 다 올리지 못할 때 
- 데이터를 나눠서 메모리에 올리고, 부분 정렬, 정렬된 런을 병합 
	1. 런 생성 ( 정렬): 메모리에 데이터를 일부만 불러와서 내부정렬 -> 런 생성
	2. 병합 (합병): 런들을 하나로 병합


1. 정렬 단계: 정렬할 화일의 레코드들을 지정된 길이의 서브화일로 분할해서 정렬하여 런을 만들어 입력 화일로 분배하는 단계
2. 합병 단계: 정렬된 런들을 합병해서 보다 더 큰 런으로 만들고 이것들을 다시 입력화일로 재분배하여 합병하는 방식으로 모든 레코드들이 하나의 런에 포함되도록 만드는 단계

## 런 생성 방법
> 1. 내부 정렬
> 2. 대체선택
> 3. 자연선택

### 1. 내부 정렬
1. 화일을 n레코드씩 분할
2. 분할한 레코드들을 내부 정렬 기법으로 정렬
- ==마지막 런을 제외하고 모두 길이가 동일== 
- ==런의 길이를 예측할 수 있으므로 합병 알고리즘이 간단==

### 2. 대체선택
- 런을 최대한 길게 만들기 위해서 사용
- 초기 버퍼 채우기 m개 
- 키 값이 가장 작은 레코드 출력
- 새 값 데이터 버퍼로 들여옴
	- lastKey(최근에 출력한애)보다 새값이 작으면 frozen
- ==버퍼에 frozene된 레코드만 남게되면 현재 런 종료==

특징 
- 내부 정렬과 달리 입력화일의 일부 정렬된 레코드들의 순서를 이용????
- ==내부 정렬을 이용한 경우보다 런의 길이가 더 길다==
- 런의 평균 예상 길이 2m
- ==런의 길이가 길 수록 합병 비용이 적음== 
- ==런의 길이가 일정치 않아 정렬/합병 알고리즘이 복잡==

단점 
- 구현이 복잡하다. frozen, written, lastkey 다양한 상태관리 필요
- 비효율적인 경우 존재 <- 역순이나 정렬이 거의 안되어있을시 
	- 이상적인 성능을 보장하진 않음
- 버퍼 등 별도의 메모리가 필요하다. 



### 3. 자연선택
- 동결된 레코드들을 버퍼에 유지하지 않고 보조 저장장치의 저장소에 별도 저장
	- 하나의 런 생성 작업은 frozen 저장소가 다 차거나 입력 화일 끝에 도달할때까지 계속
	- 런을 길게 만들어 런 수를 줄임으로서 합병 비용을 줄임 
- frozen을 위한 예비저장소가 별도로 있음 (버퍼처럼 리스트)
	- 얘가 다 차면 종료
- ==앞에 두 방법보다 더 긴 런==
- ==저장소로의 입출력이 문제가 됨== 
- ==긴 런 생성에 따른 효율화가 예비 저장소 전송 비용보다 이익이 될 수도 있음== 


## 정렬/합병 기법의 차별화 요소
- 적용하는 내부 정렬 방식 (선택, 버블, 삽입, 퀵, 힙 )
- 내부 정렬을 위해 할당된 메인 메모리의 크기
- 정렬된 런들의 보조 저장장치에서의 저장분포 (연속된/비연속된 공간에 저장)
- 동시에 처리할 수 있는 런의 수

=> 위 요소에 따라서 런의 수랑 합병의 패스 수가 결정
패스 : 런을 읽고 합병해서 더 큰런을 생성하는 단계
패스의 수가 많을 수록 디스크 접근이 많아져, 성능이 떨어지므로 ==한번의 패스에 가능한 많은 런을 병합하면 좋다.== 


- 런을 길게 만들면 합병해야하는 런의 수가 최소화
- 동시에 합병할 수 있는 런의 수를 크게하면 합병의 패스 수가 감소
- 입력 런을 분산 저장하면 부수적인 입출력연산의 비용이 발생 

# 합병

런을 합쳐서 더 큰 정렬된 집합으로 만들기
## m원 합병

- m개의 입력화일을 동시에 처리
- m+1개 화일 사용 = 입력 화일 m개 + 출력화일 1개
- 입출력이 많음: 한 패스에 합병이 되지 않으면 런을 입력화일로 다시 재분배 해야함. 복사,이동 .... 또해야함
- 이상적일려면.. m개의 런에 m개의 입력 화일을 사용해서 한번의 m원합병으로 끝
- 2원합병: 1번의 패스 = 합병된 런의 크기 2배, 런의 개수 반
- n개의 런을 정렬하기 위한 패스의 수 log N


- 입력: m개의 정렬된 런
- 출력: 1개의 정렬된 런 

1. 각 런에서 첫번째 요소를 버퍼에 로딩
2. m개의 요소 중 가장 작은 값을 선택하여 출력
3. 출력한 값이 있던 런에서 다음 요소를 버퍼에 로딩
4. 모든 런의 요소가 소진될 때까지 2~3을 반복

- m이 클수록 메모리 버퍼 크기 증가
- 모드 런에 대해 동시에 입출력을 처리 해야 하므로 디스크 수가 부족하면 비효율적
- 대용량 데이터 정렬 (하둡, 맵리듀스의 sort)

예시) 5개의 런에 대한 5원 합병
- 한번의 패스로 합병된 파일을 얻을 수 있음
- ==그러나 키값이 가장 작은 레코드를 찾기 위해서 m-1번 비교연산을 함==

## 선택트리

- 승자트리
	- 완전 이진 트리 = 완전 이원트리 -> 순차표현이 유리
		- 인덱스 값이 i인 애의 자식 인덱스는 2i, 2i+1
	- 각 단말 노드는 각 런에서 가장 작은 값을 내보냄
	- 내부노드(단말노드를 뺀 모든 노드)는 두 자식 중에 가장 작은 값을 가진 노드로 
	- 가장 작은 키 값을 가진 원소가 승자로 올라가는 토너먼트 경기
	- 루트 노드 = 트리에서 가장 작은 키 값을 가진 원소
	- 합병 
		- 루트가 결정되는 대로 순서 순차에 출력
		- 다음 원소가 승자 트리에 들어감 
		- 승자 트리를 재구성
- 패자트리
	- 승자트리에 0번 노드가 추가된 형태
	- 내부노드 : 토너먼트의 패자
		- 패자는 부모노드에 남음. 승자는 그 위로 올라가서 다시 경기 
	- 루트: 결승 토너먼트의 패자
	- 0번 : 전체 승자
	- 합병 후
		- 출력된 원소가 있는 런에서 다시 제일 작은 값을 단말 노드에 올려서 경기 진행
		- ?? 경기는 형제 노드 대신 형식상 부모노드와 경기를 함?? 
## m원 균형합병
- m원합병의 단점 : 화일 재분배에 많은 입출력 필요
- ==출력 파일이 다음 단계에서의 입력 파일이 됨.==
- m원 자연합병: m+1
- ==m원 균형합병 2m개의 화일 필요 (입력 화일 m개, 출력화일 m개)== 화일이 더 많이 필요하지만 그만큼 재분배 때문에 입출력을 안해도 된다. 
- 합병 후 ????
	- 런의 총 개수 = [처음 런의 개수 / 합병 차수]
	- 런 길이 = 합병 차수의 두배씩 증가
	- O(logm N ) N은 초기 런의 수
- 단점
	- 하나의 합병된 런이 생성되는 동안 m-1개의 파일은 항상 유휴 상태

## m원 다단계 합병



## 계단식 합병



