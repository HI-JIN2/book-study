# 정렬
## 내부 정렬
- 전체 데이터를 메인메모리에 올릴 수 있을 때
- 레코드 판독, 기록에 걸리는 시간이 문제가 되지 않음
- 종류 
	1. 버블 
	2. 삽입
	3. 선택
	4. 퀵
	5. 힙
	6. 병합

## 외부 정렬
- 데이터가 너무 커서 메인 메모리에 한 번에 다 올리지 못할 때 
- 데이터를 나눠서 메모리에 올리고, 부분 정렬, 정렬된 런을 병합 
	1. 런 생성 ( 정렬): 메모리에 데이터를 일부만 불러와서 내부정렬 -> 런 생성
	2. 병합 (합병): 런들을 하나로 병합


1. 정렬 단계: 정렬할 화일의 레코드들을 지정된 길이의 서브화일로 분할해서 정렬하여 런을 만들어 입력 화일로 분배하는 단계
2. 합병 단계: 정렬된 런들을 합병해서 보다 더 큰 런으로 만들고 이것들을 다시 입력화일로 재분배하여 합병하는 방식으로 모든 레코드들이 하나의 런에 포함되도록 만드는 단계

## 런 생성 방법
> 1. 내부 정렬
> 2. 대체선택
> 3. 자연선택

### 1. 내부 정렬
1. 화일을 n레코드씩 분할
2. 분할한 레코드들을 내부 정렬 기법으로 정렬
- ==마지막 런을 제외하고 모두 길이가 동일== 
- ==런의 길이를 예측할 수 있으므로 합병 알고리즘이 간단==

### 2. 대체선택
- 런을 최대한 길게 만들기 위해서 사용
- 초기 버퍼 채우기 m개 
- 키 값이 가장 작은 레코드 출력
- 새 값 데이터 버퍼로 들여옴
	- lastKey(최근에 출력한애)보다 새값이 작으면 frozen
- ==버퍼에 frozene된 레코드만 남게되면 현재 런 종료==

특징 
- 내부 정렬과 달리 입력화일의 일부 정렬된 레코드들의 순서를 이용????
- ==내부 정렬을 이용한 경우보다 런의 길이가 더 길다==
- 런의 평균 예상 길이 2m
- ==런의 길이가 길 수록 합병 비용이 적음== 
- ==런의 길이가 일정치 않아 정렬/합병 알고리즘이 복잡==

단점 
- 구현이 복잡하다. frozen, written, lastkey 다양한 상태관리 필요
- 비효율적인 경우 존재 <- 역순이나 정렬이 거의 안되어있을시 
	- 이상적인 성능을 보장하진 않음
- 버퍼 등 별도의 메모리가 필요하다. 



### 3. 자연선택
- 동결된 레코드들을 버퍼에 유지하지 않고 보조 저장장치의 저장소에 별도 저장
	- 하나의 런 생성 작업은 frozen 저장소가 다 차거나 입력 화일 끝에 도달할때까지 계속
	- 런을 길게 만들어 런 수를 줄임으로서 합병 비용을 줄임 
- frozen을 위한 예비저장소가 별도로 있음 (버퍼처럼 리스트)
	- 얘가 다 차면 종료
- ==앞에 두 방법보다 더 긴 런==
- ==저장소로의 입출력이 문제가 됨== 
- ==긴 런 생성에 따른 효율화가 예비 저장소 전송 비용보다 이익이 될 수도 있음== 


## 정렬/합병 기법의 차별화 요소
- 적용하는 내부 정렬 방식 (선택, 버블, 삽입, 퀵, 힙 )
- 내부 정렬을 위해 할당된 메인 메모리의 크기
- 정렬된 런들의 보조 저장장치에서의 저장분포 (연속된/비연속된 공간에 저장)
- 동시에 처리할 수 있는 런의 수

=> 위 요소에 따라서 런의 수랑 합병의 패스 수가 결정
패스 : 런을 읽고 합병해서 더 큰런을 생성하는 단계
패스의 수가 많을 수록 디스크 접근이 많아져, 성능이 떨어지므로 ==한번의 패스에 가능한 많은 런을 병합하면 좋다.== 


- 런을 길게 만들면 합병해야하는 런의 수가 최소화
- 동시에 합병할 수 있는 런의 수를 크게하면 합병의 패스 수가 감소
- 입력 런을 분산 저장하면 부수적인 입출력연산의 비용이 발생 

# 합병
## m원 합병

## 선택트리
## 다단계 합병